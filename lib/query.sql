--FUNCTION FOR Unconnected major
CREATE OR REPLACE FUNCTION task_unconnectedmajor(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM unconnectedmajor as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  unconnectedmajor; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM unconnectedmajor_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM unconnectedmajor_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM unconnectedmajor_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE unconnectedmajor  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Unconnected minor
CREATE OR REPLACE FUNCTION task_unconnectedminor(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM unconnectedminor as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  unconnectedminor; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM unconnectedminor_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM unconnectedminor_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM unconnectedminor_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE unconnectedminor  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Impossible one-ways
CREATE OR REPLACE FUNCTION task_deadendoneway(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM deadendoneway as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  deadendoneway; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM deadendoneway_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM deadendoneway_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM deadendoneway_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE deadendoneway  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Kinks
CREATE OR REPLACE FUNCTION task_impossibleangle(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM impossibleangle as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  impossibleangle; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM impossibleangle_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM impossibleangle_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM impossibleangle_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE impossibleangle  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Mixed layers
CREATE OR REPLACE FUNCTION task_mixedlayer(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM mixedlayer as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  mixedlayer; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM mixedlayer_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM mixedlayer_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM mixedlayer_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE mixedlayer  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Broken polygons
CREATE OR REPLACE FUNCTION task_nonclosedways(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM nonclosedways as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  nonclosedways; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM nonclosedways_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM nonclosedways_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM nonclosedways_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE nonclosedways  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Loopings
CREATE OR REPLACE FUNCTION task_loopings(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM loopings as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  loopings; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM loopings_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM loopings_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM loopings_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE loopings  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Strange layer
CREATE OR REPLACE FUNCTION task_strangelayer(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM strangelayer as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  strangelayer; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM strangelayer_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM strangelayer_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM strangelayer_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE strangelayer  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Highway intersects highway
CREATE OR REPLACE FUNCTION task_highwayhighway(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM highwayhighway as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  highwayhighway; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM highwayhighway_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM highwayhighway_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM highwayhighway_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE highwayhighway  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Highway intersects footpath
CREATE OR REPLACE FUNCTION task_highwayfootpath(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM highwayfootpath as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  highwayfootpath; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM highwayfootpath_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM highwayfootpath_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM highwayfootpath_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE highwayfootpath  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Highway intersects water
CREATE OR REPLACE FUNCTION task_highwayriverbank(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM highwayriverbank as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  highwayriverbank; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM highwayriverbank_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM highwayriverbank_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM highwayriverbank_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE highwayriverbank  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Misspelled tags
CREATE OR REPLACE FUNCTION task_mispelledtags(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM mispelledtags as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  mispelledtags; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM mispelledtags_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM mispelledtags_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM mispelledtags_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE mispelledtags  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR Tiger delta
CREATE OR REPLACE FUNCTION task_tigerdelta(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM tigerdelta as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  tigerdelta; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM tigerdelta_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM tigerdelta_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM tigerdelta_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE tigerdelta  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR USA overlapping buildings
CREATE OR REPLACE FUNCTION task_usabuildingoverlaps(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM usabuildingoverlaps as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  usabuildingoverlaps; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM usabuildingoverlaps_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM usabuildingoverlaps_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM usabuildingoverlaps_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE usabuildingoverlaps  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
--FUNCTION FOR krakatoa
CREATE OR REPLACE FUNCTION task_rk(lockPeriod int , now int) 			RETURNS item AS $$ 			DECLARE				result item; 			_noterror int; 			_skip int; 			_fix int; 			_total int; 			BEGIN 				SELECT x.key, x.value INTO result.key , result.value  FROM rk as x WHERE x.time < now AND x.time != 2147483647 ORDER BY time ASC LIMIT 1; 				IF result.key ISNULL THEN 					SELECT count(*) INTO _total FROM  rk; 					SELECT count(*) INTO _skip FROM (SELECT attributes FROM rk_stats WHERE attributes -> 'action' = 'skip'AND attributes ->'key' !='')as sub; 					SELECT count(*) INTO _fix FROM (SELECT attributes FROM rk_stats WHERE attributes -> 'action' = 'fix'AND attributes ->'key' !='') as sub; 					SELECT count(*) INTO _noterror FROM (SELECT attributes FROM rk_stats WHERE attributes -> 'action' = 'noterror' AND attributes ->'key' !='') as sub; 					result.value = ('{|skip|:|' || _skip||'|,|'|| 'noterror|:|'||_noterror||'|,|'||'fix|:|'||_fix||'|,|'||'total|:|'||_total||'|}'); 					result.key='complete'; 				ELSE 					UPDATE rk  SET time = (now+lockPeriod) WHERE key=result.key; 				END IF; 				RETURN result; 			END; 			$$ LANGUAGE plpgsql;
